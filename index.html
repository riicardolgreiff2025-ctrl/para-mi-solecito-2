<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>El Valor de la Paciencia</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Cormorant+Garamond:ital@1&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #06030f;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    overflow: hidden;
    font-family: 'Playfair Display', serif;
  }

  .moon-container {
    position: relative; z-index: 2;
    margin-bottom: 0px;
    height: 100px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  #main-canvas {
    display: block;
    position: relative; z-index: 2;
  }

  .bottom-quote {
    text-align: center;
    margin-top: 8px;
    position: relative; z-index: 2;
    opacity: 0;
    transition: opacity 3s ease;
  }
  .bottom-quote.visible { opacity: 1; }

  .bottom-quote .main-text {
    color: #e8c4d4;
    font-family: 'Cormorant Garamond', serif;
    font-style: italic;
    font-size: clamp(1rem, 3.5vw, 1.5rem);
    letter-spacing: 0.08em;
    text-shadow: 0 0 20px rgba(255, 107, 157, 0.3);
  }

  .bottom-quote .sub-text {
    color: #8a5a70;
    font-size: clamp(0.6rem, 2vw, 0.85rem);
    font-style: italic;
    letter-spacing: 0.18em;
    margin-top: 4px;
  }

  #particles-canvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 0;
  }

  @keyframes fadeIn { to { opacity: 1; } }
</style>
</head>
<body>

<canvas id="particles-canvas"></canvas>
<div class="moon-container">
  <canvas id="moon-canvas" width="160" height="100"></canvas>
</div>
<canvas id="main-canvas"></canvas>
<div class="bottom-quote" id="quote">
  <div class="main-text">Lo mejor florece con paciencia</div>
  <div class="sub-text">— como el amor que vale la pena —</div>
</div>

<script>
// ==============================
// PARTÍCULAS DE FONDO
// ==============================
const pc = document.getElementById('particles-canvas');
const pctx = pc.getContext('2d');
pc.width = window.innerWidth;
pc.height = window.innerHeight;

const particles = Array.from({length: 50}, () => ({
  x: Math.random() * pc.width,
  y: Math.random() * pc.height,
  r: Math.random() * 1.5 + 0.3,
  dy: -(Math.random() * 0.25 + 0.08),
  dx: (Math.random() - 0.5) * 0.15,
  alpha: Math.random() * 0.4 + 0.05,
  color: Math.random() > 0.5 ? '#ff6b9d' : '#9b59b6'
}));

function animParticles() {
  pctx.clearRect(0, 0, pc.width, pc.height);
  particles.forEach(p => {
    pctx.beginPath();
    pctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
    pctx.fillStyle = p.color;
    pctx.globalAlpha = p.alpha;
    pctx.fill();
    p.y += p.dy; p.x += p.dx;
    if (p.y < -10) { p.y = pc.height + 10; p.x = Math.random() * pc.width; }
  });
  pctx.globalAlpha = 1;
  requestAnimationFrame(animParticles);
}
animParticles();

// ==============================
// CANVAS PRINCIPAL
// ==============================
const canvas = document.getElementById('main-canvas');
const ctx = canvas.getContext('2d');

const W = window.innerWidth;
const H = Math.min(window.innerHeight * 0.72, 680);
canvas.width = W;
canvas.height = H;

const CX = W / 2;  // centro X
const GROUND = H - 15; // base del tronco

// ==============================
// ESTADO DE LA ANIMACIÓN
// ==============================
// Fases: 'watering' -> 'poof' -> 'growing' -> 'hearts' -> 'done'
let phase = 'watering';
let phaseTimer = 0;

// ---- REGADERA ----
const can = {
  x: CX - 10,
  y: GROUND - 60,
  targetY: GROUND - 120,
  alpha: 1,
  poofAlpha: 0,
  poofRadius: 0,
};

// Gotas de agua
let drops = [];
function spawnDrop() {
  drops.push({
    x: CX - 5 + (Math.random() - 0.5) * 30,
    y: can.y + 10,
    vy: 2 + Math.random() * 1.5,
    vx: (Math.random() - 0.5) * 1.2,
    alpha: 1,
    r: 2 + Math.random() * 1.5,
    life: 0,
  });
}

// ---- TRONCO PEQUEÑO inicial ----
let trunkHeight = 0;
const maxTrunkSmall = 28;

// ---- ÁRBOL FRACTAL ----
let branches = [];
let hearts = [];

function generateTree(x, y, angle, length, depth, delay) {
  if (depth === 0 || length < 2) {
    hearts.push({ x, y, delay, alpha: 0, scale: 0, color: randomHeart() });
    return;
  }
  const x2 = x + Math.cos(angle) * length;
  const y2 = y - Math.sin(angle) * length;
  const thickness = Math.max(0.5, depth * 1.5);
  branches.push({ x1: x, y1: y, x2, y2, thickness, color: branchColor(depth), delay });
  const spread = 0.38 + Math.random() * 0.14;
  const lean = (Math.random() - 0.5) * 0.10;
  generateTree(x2, y2, angle - spread + lean, length * 0.72, depth - 1, delay + 1);
  generateTree(x2, y2, angle + spread + lean, length * 0.72, depth - 1, delay + 1);
  if (depth > 3 && Math.random() > 0.65)
    generateTree(x2, y2, angle + (Math.random()-0.5)*0.15, length*0.58, depth-2, delay+1);
}

function branchColor(d) {
  if (d >= 7) return '#4a2e14';
  if (d >= 5) return '#6b3f1e';
  if (d >= 3) return '#8c5a2a';
  return '#a87040';
}

function randomHeart() {
  return ['#ff3d7f','#ff6b9d','#ff85b3','#e91e8c','#ff1744','#f06292'][Math.floor(Math.random()*6)];
}

generateTree(CX, GROUND, Math.PI/2, H * 0.185, 9, 0);
branches.sort((a,b) => a.delay - b.delay);
hearts.sort((a,b) => a.delay - b.delay);
const maxDelay = Math.max(...branches.map(b => b.delay));

// ---- DIBUJAR CORAZÓN ----
function drawHeart(x, y, size, color, alpha) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = color;
  ctx.shadowColor = color;
  ctx.shadowBlur = 10;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.bezierCurveTo(x, y-size*0.3, x-size*0.5, y-size*0.8, x-size*0.5, y-size*0.5);
  ctx.bezierCurveTo(x-size*0.5, y-size*1.1, x, y-size*1.0, x, y-size*0.7);
  ctx.bezierCurveTo(x, y-size*1.0, x+size*0.5, y-size*1.1, x+size*0.5, y-size*0.5);
  ctx.bezierCurveTo(x+size*0.5, y-size*0.8, x, y-size*0.3, x, y);
  ctx.fill();
  ctx.restore();
}

// ---- DIBUJAR REGADERA ----
function drawWateringCan(x, y, alpha) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.strokeStyle = '#c8a96e';
  ctx.fillStyle = '#8b6914';
  ctx.lineWidth = 2;
  ctx.lineCap = 'round';

  // Cuerpo principal
  ctx.beginPath();
  ctx.roundRect(x - 22, y - 18, 44, 28, 6);
  ctx.fill();
  ctx.stroke();

  // Pico (boquilla) hacia abajo-derecha
  ctx.beginPath();
  ctx.moveTo(x + 18, y - 2);
  ctx.lineTo(x + 38, y + 14);
  ctx.lineWidth = 5;
  ctx.strokeStyle = '#a07820';
  ctx.stroke();

  // Cabeza regadera (ducha)
  ctx.beginPath();
  ctx.arc(x + 38, y + 14, 6, 0, Math.PI * 2);
  ctx.fillStyle = '#c8a030';
  ctx.fill();

  // Agujeros de la ducha
  for (let i = 0; i < 5; i++) {
    const angle = (i / 4) * Math.PI * 0.8 + Math.PI * 0.6;
    ctx.beginPath();
    ctx.arc(x + 38 + Math.cos(angle) * 4, y + 14 + Math.sin(angle) * 4, 1, 0, Math.PI * 2);
    ctx.fillStyle = '#06030f';
    ctx.fill();
  }

  // Asa
  ctx.beginPath();
  ctx.arc(x - 8, y - 24, 12, Math.PI * 0.2, Math.PI * 1.1);
  ctx.lineWidth = 4;
  ctx.strokeStyle = '#a07820';
  ctx.stroke();

  ctx.restore();
}

// ---- DIBUJAR POOF (humo de desaparición) ----
function drawPoof(x, y, radius, alpha) {
  ctx.save();
  const circles = [
    {ox: 0,   oy: 0,   r: 1.0},
    {ox: -18, oy: -10, r: 0.7},
    {ox: 18,  oy: -8,  r: 0.75},
    {ox: -10, oy: -22, r: 0.6},
    {ox: 12,  oy: -20, r: 0.55},
    {ox: 0,   oy: -28, r: 0.5},
    {ox: -24, oy: 2,   r: 0.5},
    {ox: 26,  oy: 0,   r: 0.5},
  ];
  circles.forEach(c => {
    const grad = ctx.createRadialGradient(
      x + c.ox * (radius/40), y + c.oy * (radius/40), 0,
      x + c.ox * (radius/40), y + c.oy * (radius/40), radius * c.r
    );
    grad.addColorStop(0, `rgba(220, 180, 255, ${alpha * 0.6})`);
    grad.addColorStop(0.5, `rgba(150, 100, 200, ${alpha * 0.3})`);
    grad.addColorStop(1, `rgba(100, 50, 150, 0)`);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(x + c.ox*(radius/40), y + c.oy*(radius/40), radius * c.r, 0, Math.PI*2);
    ctx.fill();
  });

  // Estrellitas del poof
  if (alpha > 0.3) {
    const stars = [{ox:30,oy:-30},{ox:-35,oy:-20},{ox:20,oy:-45},{ox:-15,oy:-48},{ox:38,oy:-10}];
    stars.forEach(s => {
      ctx.save();
      ctx.globalAlpha = alpha * 0.9;
      ctx.fillStyle = '#ffcce8';
      ctx.shadowColor = '#ff6b9d';
      ctx.shadowBlur = 6;
      const sx = x + s.ox * (radius/35);
      const sy = y + s.oy * (radius/35);
      ctx.font = `${10 + radius * 0.15}px serif`;
      ctx.textAlign = 'center';
      ctx.fillText('✦', sx, sy);
      ctx.restore();
    });
  }
  ctx.restore();
}

// ==============================
// SUELO, PASTO Y ARBUSTOS
// ==============================

// Briznas de pasto generadas una sola vez
const grassBlades = Array.from({length: 180}, () => ({
  x: Math.random() * W,
  h: 6 + Math.random() * 14,
  lean: (Math.random() - 0.5) * 0.5,
  color: Math.random() > 0.4 ? '#2d6e2a' : '#3a8c36',
  width: 1 + Math.random() * 1.2,
}));

// Arbustos pequeños a los lados
const bushes = [
  // Izquierda
  { x: CX - 160, y: GROUND, r: 22, flowers: generateFlowers(CX-160, GROUND, 22, 7) },
  { x: CX - 110, y: GROUND, r: 16, flowers: generateFlowers(CX-110, GROUND, 16, 5) },
  { x: CX - 220, y: GROUND, r: 18, flowers: generateFlowers(CX-220, GROUND, 18, 6) },
  // Derecha
  { x: CX + 150, y: GROUND, r: 22, flowers: generateFlowers(CX+150, GROUND, 22, 7) },
  { x: CX + 105, y: GROUND, r: 16, flowers: generateFlowers(CX+105, GROUND, 16, 5) },
  { x: CX + 210, y: GROUND, r: 18, flowers: generateFlowers(CX+210, GROUND, 18, 6) },
];

function generateFlowers(bx, by, br, count) {
  return Array.from({length: count}, () => {
    const angle = Math.random() * Math.PI * 2;
    const dist = Math.random() * br * 0.9;
    return {
      x: bx + Math.cos(angle) * dist,
      y: by - Math.abs(Math.sin(angle) * dist * 0.6) - 4,
      color: ['#ff9ecd','#ffcce8','#fff0a0','#ffd6f7','#ffb3d9','#ffe0f0'][Math.floor(Math.random()*6)],
      size: 2.5 + Math.random() * 2,
      phase: Math.random() * Math.PI * 2,
    };
  });
}

function drawTrunk(progress) {
  const trunkH = H * 0.22 * progress;
  if (trunkH < 2) return;
  ctx.save();
  // Tronco con gradiente de color más oscuro abajo, más claro arriba
  const grad = ctx.createLinearGradient(CX - 12, GROUND, CX + 12, GROUND - trunkH);
  grad.addColorStop(0, '#3a1e08');
  grad.addColorStop(0.5, '#5c3a1e');
  grad.addColorStop(1, '#7a4f2a');

  // Dibujar tronco como path con curvatura y grosor variable
  const topW = 5;   // grosor arriba
  const botW = 14;  // grosor abajo
  const curveX = 6; // curvatura lateral suave

  ctx.beginPath();
  ctx.moveTo(CX - botW, GROUND);
  ctx.quadraticCurveTo(CX - botW * 0.4 + curveX, GROUND - trunkH * 0.5, CX - topW, GROUND - trunkH);
  ctx.lineTo(CX + topW, GROUND - trunkH);
  ctx.quadraticCurveTo(CX + botW * 0.4 + curveX, GROUND - trunkH * 0.5, CX + botW, GROUND);
  ctx.closePath();
  ctx.fillStyle = grad;
  ctx.fill();

  // Textura de corteza — líneas verticales sutiles
  ctx.strokeStyle = 'rgba(30, 10, 0, 0.3)';
  ctx.lineWidth = 0.8;
  for (let i = 0; i < 3; i++) {
    const lx = CX - 5 + i * 5;
    ctx.beginPath();
    ctx.moveTo(lx, GROUND - 5);
    ctx.quadraticCurveTo(lx + 2, GROUND - trunkH * 0.5, lx, GROUND - trunkH + 10);
    ctx.stroke();
  }
  ctx.restore();
}

function drawGround() {
  // Capa de tierra
  const dirtGrad = ctx.createLinearGradient(0, GROUND - 4, 0, GROUND + 18);
  dirtGrad.addColorStop(0, '#3d1f0a');
  dirtGrad.addColorStop(1, '#1a0a03');
  ctx.fillStyle = dirtGrad;
  ctx.beginPath();
  ctx.ellipse(CX, GROUND + 8, W * 0.52, 22, 0, 0, Math.PI * 2);
  ctx.fill();

  // Capa de pasto encima
  const grassGrad = ctx.createLinearGradient(0, GROUND - 8, 0, GROUND + 2);
  grassGrad.addColorStop(0, '#2a6e1a');
  grassGrad.addColorStop(1, '#1a4a10');
  ctx.fillStyle = grassGrad;
  ctx.beginPath();
  ctx.ellipse(CX, GROUND, W * 0.50, 12, 0, 0, Math.PI * 2);
  ctx.fill();

  // Briznas de pasto individuales
  const t = Date.now() * 0.001;
  grassBlades.forEach(g => {
    const sway = Math.sin(t * 0.8 + g.x * 0.05) * 0.15;
    const lean = g.lean + sway;
    ctx.save();
    ctx.strokeStyle = g.color;
    ctx.lineWidth = g.width;
    ctx.lineCap = 'round';
    ctx.globalAlpha = 0.85;
    ctx.beginPath();
    ctx.moveTo(g.x, GROUND);
    ctx.quadraticCurveTo(
      g.x + lean * g.h * 8,
      GROUND - g.h * 0.6,
      g.x + lean * g.h * 14,
      GROUND - g.h
    );
    ctx.stroke();
    ctx.restore();
  });
}

function drawBushes(showFlowers) {
  const t = Date.now() * 0.001;
  bushes.forEach(bush => {
    // Arbusto verde
    const grad = ctx.createRadialGradient(bush.x, bush.y - bush.r*0.3, 2, bush.x, bush.y, bush.r);
    grad.addColorStop(0, '#4a9e3a');
    grad.addColorStop(0.6, '#2d7022');
    grad.addColorStop(1, '#1a4a10');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(bush.x, bush.y - bush.r * 0.5, bush.r, 0, Math.PI * 2);
    ctx.fill();

    // Segunda capa para volumen
    ctx.fillStyle = 'rgba(60, 130, 40, 0.4)';
    ctx.beginPath();
    ctx.arc(bush.x - bush.r*0.3, bush.y - bush.r*0.6, bush.r*0.7, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(bush.x + bush.r*0.3, bush.y - bush.r*0.55, bush.r*0.65, 0, Math.PI*2);
    ctx.fill();

    // Florecitas
    if (showFlowers) {
      bush.flowers.forEach(f => {
        const sway = Math.sin(t * 1.2 + f.phase) * 0.8;
        const px = f.x + sway;
        const py = f.y;
        // Pétalos
        for (let p = 0; p < 5; p++) {
          const a = (p / 5) * Math.PI * 2;
          ctx.save();
          ctx.globalAlpha = 0.9;
          ctx.fillStyle = f.color;
          ctx.shadowColor = f.color;
          ctx.shadowBlur = 3;
          ctx.beginPath();
          ctx.ellipse(
            px + Math.cos(a) * f.size * 0.9,
            py + Math.sin(a) * f.size * 0.9,
            f.size * 0.55, f.size * 0.4, a, 0, Math.PI * 2
          );
          ctx.fill();
          ctx.restore();
        }
        // Centro amarillo
        ctx.save();
        ctx.fillStyle = '#ffe066';
        ctx.shadowColor = '#ffcc00';
        ctx.shadowBlur = 2;
        ctx.beginPath();
        ctx.arc(px, py, f.size * 0.4, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }
  });
}

// ==============================
// LOOP PRINCIPAL
// ==============================
let frame = 0;
let growFrame = 0;
let dropTimer = 0;
let floatingHearts = [];

function animate() {
  ctx.clearRect(0, 0, W, H);

  phaseTimer++;

  // Suelo y pasto siempre presentes
  drawGround();
  const showFlowers = (phase === 'hearts' || phase === 'done');
  drawBushes(showFlowers);

  // ---- FASE: REGANDO ----
  if (phase === 'watering') {
    // Regadera sube suavemente
    if (can.y > can.targetY) can.y -= 0.8;

    // Generar gotas
    dropTimer++;
    if (dropTimer % 5 === 0) spawnDrop();

    // Tronco pequeño crece lento
    if (trunkHeight < maxTrunkSmall) trunkHeight += 0.3;

    // Dibujar gotas
    drops.forEach(d => {
      d.x += d.vx; d.y += d.vy; d.vy += 0.12;
      d.life++;
      d.alpha = Math.max(0, 1 - d.life / 35);
      if (d.alpha <= 0) return;
      ctx.save();
      ctx.globalAlpha = d.alpha * 0.85;
      ctx.fillStyle = '#7ec8e3';
      ctx.shadowColor = '#a8e4f7';
      ctx.shadowBlur = 4;
      ctx.beginPath();
      ctx.ellipse(d.x, d.y, d.r * 0.6, d.r, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    });
    drops = drops.filter(d => d.alpha > 0);

    // Dibujar tronco pequeño
    if (trunkHeight > 0) {
      ctx.save();
      ctx.strokeStyle = '#5c3a1e';
      ctx.lineWidth = 5;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(CX, GROUND);
      ctx.lineTo(CX, GROUND - trunkHeight);
      ctx.stroke();
      ctx.restore();
    }

    // Dibujar regadera
    drawWateringCan(can.x, can.y, can.alpha);

    // Cambiar fase después de ~3.5 segundos
    if (phaseTimer > 210) {
      phase = 'poof';
      phaseTimer = 0;
      drops = [];
    }
  }

  // ---- FASE: POOF ----
  else if (phase === 'poof') {
    // Tronco permanece
    ctx.save();
    ctx.strokeStyle = '#5c3a1e';
    ctx.lineWidth = 5;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(CX, GROUND);
    ctx.lineTo(CX, GROUND - trunkHeight);
    ctx.stroke();
    ctx.restore();

    const t = phaseTimer / 60; // 0 a 1 en 60 frames
    can.poofRadius = t * 55;
    can.poofAlpha = t < 0.4 ? t / 0.4 : 1 - (t - 0.4) / 0.6;
    can.alpha = Math.max(0, 1 - t * 3);

    if (can.alpha > 0) drawWateringCan(can.x, can.y, can.alpha);
    if (can.poofAlpha > 0) drawPoof(can.x, can.y, can.poofRadius, can.poofAlpha);

    if (phaseTimer > 75) {
      phase = 'growing';
      phaseTimer = 0;
    }
  }

  // ---- FASE: CRECIMIENTO DEL ÁRBOL ----
  else if (phase === 'growing') {
    growFrame++;
    const currentDelay = growFrame * 0.042;

    branches.forEach(b => {
      if (b.delay > currentDelay) return;
      const progress = Math.min(1, (currentDelay - b.delay) / 3.5);
      const ex = b.x1 + (b.x2 - b.x1) * progress;
      const ey = b.y1 + (b.y2 - b.y1) * progress;
      ctx.beginPath();
      ctx.moveTo(b.x1, b.y1);
      ctx.lineTo(ex, ey);
      ctx.strokeStyle = b.color;
      ctx.lineWidth = b.thickness;
      ctx.lineCap = 'round';
      ctx.shadowColor = 'rgba(150, 80, 30, 0.15)';
      ctx.shadowBlur = 2;
      ctx.stroke();
      ctx.shadowBlur = 0;
    });

    if (currentDelay > maxDelay + 8) {
      phase = 'hearts';
      phaseTimer = 0;
    }

    // Tronco principal grueso con curvatura
    drawTrunk(Math.min(1, growFrame * 0.01));
  }

  // ---- FASE: CORAZONES ----
  else if (phase === 'hearts' || phase === 'done') {
    drawTrunk(1);
    // Dibujar árbol completo
    branches.forEach(b => {
      ctx.beginPath();
      ctx.moveTo(b.x1, b.y1);
      ctx.lineTo(b.x2, b.y2);
      ctx.strokeStyle = b.color;
      ctx.lineWidth = b.thickness;
      ctx.lineCap = 'round';
      ctx.stroke();
    });

    const heartFrame = phase === 'hearts' ? phaseTimer : 99999;
    const hd = heartFrame * 0.06;

    hearts.forEach(h => {
      const progress = Math.min(1, (hd - h.delay * 0.25) / 5);
      if (progress <= 0) return;
      h.alpha = Math.min(1, progress * 1.8);
      h.scale = progress < 0.5 ? progress * 2 * 1.2 : 1.2 - (progress - 0.5) * 0.4;
      drawHeart(h.x, h.y, 6.5 * h.scale, h.color, h.alpha);
    });

    // Pulso suave en fase done
    if (phase === 'done') {
      const t = Date.now() * 0.001;
      hearts.forEach((h, i) => {
        const pulse = 1 + Math.sin(t * 1.5 + i * 0.4) * 0.08;
        drawHeart(h.x, h.y, 6.5 * pulse, h.color, 0.85);
      });
    }

    if (phase === 'hearts' && phaseTimer > 120) {
      phase = 'done';
      document.getElementById('quote').classList.add('visible');
    }
  }

  // ---- CORAZONES FLOTANTES QUE SE DESPRENDEN ----
  if (phase === 'done') {
    // Spawn ocasional de corazón flotante
    if (Math.random() < 0.025 && hearts.length > 0) {
      const origin = hearts[Math.floor(Math.random() * hearts.length)];
      floatingHearts.push({
        x: origin.x,
        y: origin.y,
        vy: -(0.4 + Math.random() * 0.5),
        vx: (Math.random() - 0.5) * 0.4,
        alpha: 0.9,
        size: 4 + Math.random() * 4,
        color: origin.color,
        wave: Math.random() * Math.PI * 2,
        waveSpeed: 0.03 + Math.random() * 0.02,
        age: 0,
      });
    }

    // Dibujar y actualizar corazones flotantes
    floatingHearts.forEach(fh => {
      fh.age++;
      fh.y += fh.vy;
      fh.wave += fh.waveSpeed;
      fh.x += Math.sin(fh.wave) * 0.5 + fh.vx;
      fh.alpha = Math.max(0, fh.alpha - 0.005);
      if (fh.alpha > 0) drawHeart(fh.x, fh.y, fh.size, fh.color, fh.alpha);
    });
    floatingHearts = floatingHearts.filter(fh => fh.alpha > 0);
  }

  frame++;
  requestAnimationFrame(animate);
}

animate();

// ==============================
// LUNA CON BRILLO Y NEBLINA
// ==============================
const moonCanvas = document.getElementById('moon-canvas');
const mctx = moonCanvas.getContext('2d');
const MW = 160, MH = 100;
const MX = MW / 2, MY = MH / 2 + 5;
const MOON_R = 26;

function drawMoon(t) {
  mctx.clearRect(0, 0, MW, MH);

  // Halo exterior pulsante
  const haloSize = MOON_R + 14 + Math.sin(t * 0.8) * 3;
  const halo = mctx.createRadialGradient(MX, MY, MOON_R * 0.8, MX, MY, haloSize);
  halo.addColorStop(0, 'rgba(255, 240, 180, 0.18)');
  halo.addColorStop(0.5, 'rgba(255, 220, 120, 0.08)');
  halo.addColorStop(1, 'rgba(255, 200, 80, 0)');
  mctx.fillStyle = halo;
  mctx.beginPath();
  mctx.arc(MX, MY, haloSize, 0, Math.PI * 2);
  mctx.fill();

  // Neblina / nube suave alrededor
  const neblaAlpha = 0.06 + Math.sin(t * 0.4) * 0.02;
  for (let i = 0; i < 3; i++) {
    const nx = MX + Math.cos(t * 0.2 + i * 2.1) * 18;
    const ny = MY + Math.sin(t * 0.15 + i * 1.8) * 8;
    const nebla = mctx.createRadialGradient(nx, ny, 0, nx, ny, 28 + i * 6);
    nebla.addColorStop(0, `rgba(200, 220, 255, ${neblaAlpha})`);
    nebla.addColorStop(1, 'rgba(150, 180, 255, 0)');
    mctx.fillStyle = nebla;
    mctx.beginPath();
    mctx.ellipse(nx, ny, 30 + i*5, 14 + i*3, Math.sin(t*0.1+i) * 0.3, 0, Math.PI*2);
    mctx.fill();
  }

  // Cuerpo de la luna — círculo lleno con gradiente
  const moonGrad = mctx.createRadialGradient(MX - 6, MY - 6, 2, MX, MY, MOON_R);
  moonGrad.addColorStop(0, '#fffde0');
  moonGrad.addColorStop(0.4, '#fef3b0');
  moonGrad.addColorStop(0.8, '#f5d96a');
  moonGrad.addColorStop(1, '#c8a830');
  mctx.fillStyle = moonGrad;
  mctx.shadowColor = 'rgba(255, 230, 100, 0.7)';
  mctx.shadowBlur = 18 + Math.sin(t * 0.9) * 4;
  mctx.beginPath();
  mctx.arc(MX, MY, MOON_R, 0, Math.PI * 2);
  mctx.fill();
  mctx.shadowBlur = 0;

  // Cráteres con relieve (sombra interna simulada)
  const craters = [
    { cx: MX - 8,  cy: MY - 6,  r: 5,   depth: 0.7 },
    { cx: MX + 9,  cy: MY + 4,  r: 3.5, depth: 0.6 },
    { cx: MX - 2,  cy: MY + 9,  r: 2.8, depth: 0.5 },
    { cx: MX + 4,  cy: MY - 12, r: 2.2, depth: 0.5 },
    { cx: MX - 14, cy: MY + 4,  r: 2,   depth: 0.4 },
  ];

  craters.forEach(c => {
    // Solo si está dentro del círculo lunar
    const dist = Math.sqrt((c.cx-MX)**2 + (c.cy-MY)**2);
    if (dist + c.r > MOON_R) return;

    // Sombra del cráter (lado oscuro)
    const craterDark = mctx.createRadialGradient(
      c.cx + c.r * 0.3, c.cy + c.r * 0.3, 0,
      c.cx, c.cy, c.r
    );
    craterDark.addColorStop(0, `rgba(180, 140, 20, ${c.depth * 0.5})`);
    craterDark.addColorStop(0.6, `rgba(160, 120, 10, ${c.depth * 0.3})`);
    craterDark.addColorStop(1, 'rgba(200, 160, 40, 0)');
    mctx.fillStyle = craterDark;
    mctx.beginPath();
    mctx.arc(c.cx, c.cy, c.r, 0, Math.PI * 2);
    mctx.fill();

    // Borde iluminado del cráter (lado claro)
    mctx.strokeStyle = `rgba(255, 250, 200, ${c.depth * 0.4})`;
    mctx.lineWidth = 0.8;
    mctx.beginPath();
    mctx.arc(c.cx - c.r*0.2, c.cy - c.r*0.2, c.r * 0.85, Math.PI * 1.1, Math.PI * 0.1);
    mctx.stroke();
  });

  // Brillo superior izquierdo (reflejo de luz)
  const shine = mctx.createRadialGradient(MX - 9, MY - 10, 0, MX - 9, MY - 10, 12);
  shine.addColorStop(0, 'rgba(255, 255, 240, 0.45)');
  shine.addColorStop(1, 'rgba(255, 255, 200, 0)');
  mctx.fillStyle = shine;
  mctx.beginPath();
  mctx.arc(MX - 9, MY - 10, 12, 0, Math.PI * 2);
  mctx.fill();
}

function animateMoon() {
  drawMoon(Date.now() * 0.001);
  requestAnimationFrame(animateMoon);
}
animateMoon();

window.addEventListener('resize', () => {
  pc.width = window.innerWidth;
  pc.height = window.innerHeight;
});
</script>
</body>
</html>
